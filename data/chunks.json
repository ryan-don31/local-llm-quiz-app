{
  "9c8fe1bc-27d6-435c-a527-07febcc07333": {
    "text": "CSCI 3090 OpenGL Programming Part One Muhammad Usman Faculty of Science Ontario Tech CSCI 3090 OpenGL Programming - Part One 2 Goals • At the end of this part of the course you will be able to: • Implement simple graphics applications using OpenGL • Utilize support libraries that simplify the development of graphics applications • Understand the structure of modern graphics applications CSCI 3090 OpenGL Programming - Part One 3 Why OpenGL? • Widest range of platforms: • High end graphics workstations to cell phones and cars to web browsers • Open standard, can be implemented anywhere • By far the most popular 3D graphics package CSCI 3090 OpenGL Programming - Part One 4 Why Not Vulkan? • I am sure some of you have heard of Vulkan, a newer high- performance graphics library • If it’s newer, why aren’t we doing it? • High-performance graphics, but: • The simplest Vulkan program is over 2000 lines long • It takes several lectures to cover just this program • Vulkan has a lot of power, but it’s not programmer-friendly CSCI 3090 OpenGL Programming - Part One 5 Red Book • The OpenGL Programming Guide has been viewed as the standard reference on OpenGL programming • Original versions written by standard authors, so very reliable • Not always the case now • It is called the “Red Book” due to the cover colour; this is how people refer to it CSCI 3090 OpenGL Programming - Part One 6 OpenGL SuperBible • Over the years this has developed into quite a good book • I now think it is better than the “Red Book”, though it may not be quite as up to date • It is a better book to learn from, and all of their examples work! CSCI 3090 OpenGL Programming - Part One 7 Introduction • Graphics hardware has changed significantly over the past 15 years • Graphics software has changed in response • We can write more powerful and efficient programs, but it is a steeper learning curve • The first OpenGL program used to be fairly simple, few new concepts • Now we need a lot of new concepts, even for the most basic program • The current version is not particularly easy to learn, pay attention to the examples and labs CSCI 3090 OpenGL Programming - Part One 8 Introduction • To make life easier we"
  },
  "c0572fb9-1a96-4b57-80f5-f05608b8a369": {
    "text": "has changed in response • We can write more powerful and efficient programs, but it is a steeper learning curve • The first OpenGL program used to be fairly simple, few new concepts • Now we need a lot of new concepts, even for the most basic program • The current version is not particularly easy to learn, pay attention to the examples and labs CSCI 3090 OpenGL Programming - Part One 8 Introduction • To make life easier we will be using three libraries that simplify application development: • glfw: simple application framework for OpenGL programs • glew: configure the OpenGL library for our program • glm: matrix package CSCI 3090 OpenGL Programming - Part One 9 Introduction • All the examples are on Canvas so you can run them yourself • These examples are Visual Studio 2019 projects, but they will also work with other recent versions of Visual Studio • The examples also run on Linux using the same source code, each example includes a Makefile that can be used to build the example • The Windows environment is more complicated, so we will walk through it on the following slides • On Windows, these projects expect a certain directory structure, which you should mirror on your laptop CSCI 3090 OpenGL Programming - Part One 10 Introduction • Create a CSCI 3090 folder on the C drive • Note there is a space between the I and the 3 • Download the glfw, glew and glm libraries from the Resources module • There is one zip file that needs to be expanded, it should be expanded directly into the C:\\CSCI 3090 folder • The following slide shows the directory structure, you can add FreeImage later, we won’t need it for several weeks • You can create an Examples folder any place you like, this is where you will download the examples CSCI 3090 OpenGL Programming - Part One 11 Introduction CSCI 3090 OpenGL Programming - Part One 12 Introduction • Under both glfw and glew you will find include and lib directories • We will be using the x64 versions of these libraries. Note that this is not the default for Visual Studio, you will need to check this before you build • Both of these libraries have dll’s, which you will need to copy to the folder containing the executables for your programs CSCI 3090 OpenGL"
  },
  "f896f424-07f7-452f-9232-354905f72940": {
    "text": "One 11 Introduction CSCI 3090 OpenGL Programming - Part One 12 Introduction • Under both glfw and glew you will find include and lib directories • We will be using the x64 versions of these libraries. Note that this is not the default for Visual Studio, you will need to check this before you build • Both of these libraries have dll’s, which you will need to copy to the folder containing the executables for your programs CSCI 3090 OpenGL Programming - Part One 13 Introduction CSCI 3090 OpenGL Programming - Part One 14 This is important Introduction • What if I am not using Windows?? • All three libraries are available under Linux • First check for pre-compiled packages • If not available, you will need to build them • Glm is include files only, so nothing needs to be done for it • There are instructions for doing this in the Resources module CSCI 3090 OpenGL Programming - Part One 15 Hardware Evolution • Originally each stage of the graphics pipeline was implemented by a separate hardware unit • Programmer had little control over hardware, optimized for average application • Started introducing small amount of programming for pixel operations, called fragment programs • Then added vertex programs for processing individual vertices CSCI 3090 OpenGL Programming - Part One 16 Hardware Evolution • Programs were short assembly language, only used for specialized applications • Soon evolved to larger programs and programming languages • Having separate vertex and fragment processors caused performance problems • Now have just one type of processor, can handle all types of programs CSCI 3090 OpenGL Programming - Part One 17 Hardware Evolution • Have added other types of programs, but won’t discuss them now • OpenGL has its own programming language for vertex and fragment programs, GLSL, similar to C • Compile GLSL programs within the OpenGL program and download them to the GPU (Graphics Processing Unit) • Yes, we are dealing with two programs that are compiled separately • The GLSL program are compiled in the graphics driver CSCI 3090 OpenGL Programming - Part One 18 Hardware Evolution • Most GPUs have hundreds or thousands of processors • Process many vertices and fragments in parallel, this is where performance comes from • We need to prepare the data to be sent to the GPU and the programs that will process it • This requires"
  },
  "0b2dc41d-f0c3-4f74-a263-879146f9c4a8": {
    "text": "Processing Unit) • Yes, we are dealing with two programs that are compiled separately • The GLSL program are compiled in the graphics driver CSCI 3090 OpenGL Programming - Part One 18 Hardware Evolution • Most GPUs have hundreds or thousands of processors • Process many vertices and fragments in parallel, this is where performance comes from • We need to prepare the data to be sent to the GPU and the programs that will process it • This requires a bit of code CSCI 3090 OpenGL Programming - Part One 19 Multiple Processors • Key thing to remember we are running programs on two processors: • OpenGL on the CPU • GLSL on the GPU • Both processors execute at their own rate with little interaction • We set up the GPU program through our CPU program and then let it run • This makes debugging difficult, have no way of knowing what’s gone wrong on the GPU, more on this later CSCI 3090 OpenGL Programming - Part One 20 Multiple Processors • Really dealing with two programs, one on CPU and one on GPU CPU Program Interface (driver) GPU Program CSCI 3090 OpenGL Programming - Part One 21 Multiple Processors • There also needs to be some way of getting the model or data to the GPU • The GPU doesn’t have a disk or similar device, so this data must come from the CPU • On the CPU we set up buffers, contain the model data, then send this data to the GPU • The GPU has plenty of memory so it can store this data locally • We just need to have more code to set up the buffer and send it to the GPU CSCI 3090 OpenGL Programming - Part One 22 Example One • Our first example displays a single 2D triangle on the screen • This isn’t very interesting, but it illustrates the basic structure of an OpenGL program • The main things that we need to do to get something displayed on the screen • Later we will look at 3D CSCI 3090 OpenGL Programming - Part One 23 Example One CSCI 3090 OpenGL Programming - Part One 24 Example One • Our triangle has 3 vertices, we need to have their coordinates and pass them to the GPU • We pass this data to the GPU in a buffer, basically an"
  },
  "95131e8e-d792-4775-9b90-caaf59b59a0d": {
    "text": "basic structure of an OpenGL program • The main things that we need to do to get something displayed on the screen • Later we will look at 3D CSCI 3090 OpenGL Programming - Part One 23 Example One CSCI 3090 OpenGL Programming - Part One 24 Example One • Our triangle has 3 vertices, we need to have their coordinates and pass them to the GPU • We pass this data to the GPU in a buffer, basically an array of vertices • We also need to tell the GPU the vertices that are in each triangle • We use another buffer for this • We package this as a vertex array object CSCI 3090 OpenGL Programming - Part One 25 Example One • This is done in our init() procedure, called once at the start of our program • The first few lines of this procedure is shown on the next slide • Start with some declarations, note that OpenGL defines some of its own types • We then create our vertex array object • We first create an integer identifier for this object and then bind it CSCI 3090 OpenGL Programming - Part One 26 Example One GLuint vbuffer; GLint vPosition; int vs; int fs; glGenVertexArrays(1, &triangleVAO); glBindVertexArray(triangleVAO); GLfloat vertices[3][2] = { // coordinates of triangle vertices { -0.5, -0.5 }, { 0.0, 0.5}, { 0.5, -0.5} }; GLushort indexes[3] = { 0, 1, 2 }; // indexes of triangle vertices CSCI 3090 OpenGL Programming - Part One 27 Example One • We have no direct access to any of the OpenGL data structures • Most of them are kept internal in the driver, or even on the GPU • We reference these resources using an integer ID, we will use this for all the resources in OpenGL • The call to glGenVertexArrays has two parameters, the first is the number of IDs to be generated, and the second is where these IDs will be stored • The glBindVertexArraycall specifies the vertex array that we will be manipulating CSCI 3090 OpenGL Programming - Part One 28 Example One • What is a vertex array object (VAO), and why do I need one? • It packages all the information on all (or part) of our model, the triangles that we need to draw • There is a lot of information to specify every time we want to draw"
  },
  "eada01fb-88e0-4169-b9c7-ebcdac44fb77": {
    "text": "the second is where these IDs will be stored • The glBindVertexArraycall specifies the vertex array that we will be manipulating CSCI 3090 OpenGL Programming - Part One 28 Example One • What is a vertex array object (VAO), and why do I need one? • It packages all the information on all (or part) of our model, the triangles that we need to draw • There is a lot of information to specify every time we want to draw our model, we use the init procedure to create all of this information • By packaging it in a vertex array object I only need to specify the VAO when I draw something saving dozens of lines of code CSCI 3090 OpenGL Programming - Part One 29 Example One CSCI 3090 OpenGL Programming - Part One 30 • The vertices array contains the 2D coordinates of the three triangle vertices • The indexes array contains one entry for each triangle vertex, it gives the index in the vertices array for that vertex • This makes more sense when we have larger models where a vertex can appear in more than one triangle • More on this when we discuss models in more detail Example One 0 1 2 CSCI 3090 OpenGL Programming - Part One 31 Example One • Now we need to package this data so it can be sent to the GPU • This is sent in buffers, and each buffer must have an integer name • The glGenBuffers() procedure does this for us, the first parameter is the number of names that we need • The second parameter is an array that will hold the names • This is the same as we saw with glGenVertexArrays, this pattern will repeat itself through all our programs CSCI 3090 OpenGL Programming - Part One 32 Example One glGenBuffers(1, &vbuffer); glBindBuffer(GL_ARRAY_BUFFER, vbuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), NULL, GL_STATIC_DRAW); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glGenBuffers(1, &ibuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indexes), indexes, GL_STATIC_DRAW); CSCI 3090 OpenGL Programming - Part One 33 Example One • Once we have done this we bind the buffer name • The glBindBuffer() procedure is used for this • The first parameter is the binding point, and the second parameter is the buffer name • The binding point tells OpenGL how the data will be used • Now we are ready to load the data into the buffer • There are"
  },
  "e5b7be1b-b19f-4e14-9174-651df98b01b2": {
    "text": "glGenBuffers(1, &ibuffer); glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, ibuffer); glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indexes), indexes, GL_STATIC_DRAW); CSCI 3090 OpenGL Programming - Part One 33 Example One • Once we have done this we bind the buffer name • The glBindBuffer() procedure is used for this • The first parameter is the binding point, and the second parameter is the buffer name • The binding point tells OpenGL how the data will be used • Now we are ready to load the data into the buffer • There are two ways of doing this glBindBuffer(GL_ARRAY_BUFFER, vbuffer); CSCI 3090 OpenGL Programming - Part One 34 Example One • In the case of the indexes, we do this with one call to glBufferData • This call allocates space for the data and copies the data into the buffer • The parameters to this procedure are the binding point, the amount of space to allocate, the data to be copied into the buffer, and finally, a flag to indicate where the data should be allocated glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), NULL, GL_STATIC_DRAW); CSCI 3090 OpenGL Programming - Part One 35 Example One • In the second approach, the space is allocated by glBufferData and the data is copied in separately by glBufferSubData • We pass NULL as the third parameter to glBufferData to indicate that it only allocates space • The glBufferSubData parameters are the binding point, the location where the copy starts, the number of bytes of copy and the data to be copied glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); CSCI 3090 OpenGL Programming - Part One 36 Example One • Why would we want to do this?? • A vertex can have more than coordinate data, for example normal vectors, we can only do this using the second approach • Note: in this case we have stored the vertex and index data in arrays • We can use sizeof() on these arrays to compute the number of bytes required to store the data, and the number of bytes to be copied • Later we will dynamically create the data, in that case you will need to compute the number of bytes CSCI 3090 OpenGL Programming - Part One 37 Example One • Now we are ready to compile the GPU programs • The following three lines does this for us: vs = buildShader(GL_VERTEX_SHADER, \"example1.vs\"); fs = buildShader(GL_FRAGMENT_SHADER, \"example1.fs\"); program = buildProgram(vs,fs,0); • Compiling shader programs is a complex task, I’ve provided some procedures to simplify"
  },
  "c54f45e4-d6a8-4348-a23d-066219b475e1": {
    "text": "number of bytes to be copied • Later we will dynamically create the data, in that case you will need to compute the number of bytes CSCI 3090 OpenGL Programming - Part One 37 Example One • Now we are ready to compile the GPU programs • The following three lines does this for us: vs = buildShader(GL_VERTEX_SHADER, \"example1.vs\"); fs = buildShader(GL_FRAGMENT_SHADER, \"example1.fs\"); program = buildProgram(vs,fs,0); • Compiling shader programs is a complex task, I’ve provided some procedures to simplify the process • You can examine the source code for these procedures if you are interested CSCI 3090 OpenGL Programming - Part One 38 Example One • The procedures for compiling the shader programs are in Shaders.h and Shaders.cpp • The buildShader procedure compiles a shader, the first parameter is the type of shader and the second parameter is the file where the shader is stored • The buildProgram procedure takes a zero-terminated list of shaders and produces a complete shader program • A complete shader program needs both a vertex and fragment shader • Now we need to link the vertex data to the shader program, the code on the next slide shows how this is done CSCI 3090 OpenGL Programming - Part One 39 Example One glUseProgram(program); vPosition = glGetAttribLocation(program,\"vPosition\"); glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, 0); glEnableVertexAttribArray(vPosition); • The glUseProgram procedure states that we are going to use the program we just produced • An OpenGL program can have multiple GLSL programs, and this allows us to switch between them • Our vertex program has a variable called vPosition, this is the variable that will get the vertex data CSCI 3090 OpenGL Programming - Part One 40 Example One • The glGetAttribLocation() procedure finds the location of this variable in the GLSL program so we can reference it • This will return a positive integer • We could compute this location by hand, some examples on the Internet do this, but this is a good source of bugs • If you change the shader program these locations could change, there is no check that you are setting the right variable • The glVertexAttribPointerprocedure then performs the link between the variable and the data CSCI 3090 OpenGL Programming - Part One 41 Example One • The first parameter to this procedure is the variable pointer, in this case vPosition • The second parameter is the size of the data,"
  },
  "698297a1-7086-4a15-a4e8-03a04ed6ebdd": {
    "text": "do this, but this is a good source of bugs • If you change the shader program these locations could change, there is no check that you are setting the right variable • The glVertexAttribPointerprocedure then performs the link between the variable and the data CSCI 3090 OpenGL Programming - Part One 41 Example One • The first parameter to this procedure is the variable pointer, in this case vPosition • The second parameter is the size of the data, in its data units • In our case we have 2 coordinates • The third parameter is the type of data, in this case it is floating-point data • The fourth parameter is whether the data needs to be normalized, this is mainly used when we are converting one type of data into another, which we won’t be doing glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, 0); CSCI 3090 OpenGL Programming - Part One 42 Example One • The fifth parameter is the stride, the distance in bytes between data values • Our vertices occur one after the other in the buffer, so we use a value of zero • The final parameter is the location in bytes where the data starts in the buffer • The glEnableVertexAttribArrayprocedure enables the use of the vertex data that we have just set up CSCI 3090 OpenGL Programming - Part One 43 Example One • This may seem overly complicated, but remember we are producing the data on the CPU and sending it to the GPU • The glVertexAttribPointerprocedure has a large number of parameters to give us flexibility in how we lay out our data • The stride parameters allows us to use the same data structure for both our application and graphics • There can be other values in this data structure, the stride parameter allows us to skip over these values CSCI 3090 OpenGL Programming - Part One 44 Example One • Now that we have set all this up, we need to display it • The function on the next slide is called each time we need to update the screen • We start by clearing the screen • Then we tell OpenGL which GLSL program to use • We then specify the buffer array object that contains our data CSCI 3090 OpenGL Programming - Part One 45 Example One void displayFunc() { glClear(GL_COLOR_BUFFER_BIT); glUseProgram(program); glBindVertexArray(triangleVAO); glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT , NULL);"
  },
  "69e15db5-6297-4567-a312-9f44c5ea07ee": {
    "text": "Now that we have set all this up, we need to display it • The function on the next slide is called each time we need to update the screen • We start by clearing the screen • Then we tell OpenGL which GLSL program to use • We then specify the buffer array object that contains our data CSCI 3090 OpenGL Programming - Part One 45 Example One void displayFunc() { glClear(GL_COLOR_BUFFER_BIT); glUseProgram(program); glBindVertexArray(triangleVAO); glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT , NULL); } CSCI 3090 OpenGL Programming - Part One 46 Example One • Finally, we use glDrawElements to draw the triangle • The data we want to draw is triangles, so that is the first parameter (we can also draw points and lines) • The second parameter is the number of vertices and the third parameter is the type of index data, the data in GL_ELEMENT_ARRAY_BUFFER • The fourth parameter is an offset within the indices array where the drawing starts CSCI 3090 OpenGL Programming - Part One 47 Example One • Again, this seems overly complex, but it gives us some extra flexibility • We only have one triangle in this program, but later we will have many triangles • We can have the vertices for more than one object stored in our vertex array • There will be a separate part of the index array for each of these objects • There are more complicated draw calls that allow us to draw multiple objects at the same time CSCI 3090 OpenGL Programming - Part One 48 Example One • The last thing we need for this part of the example is the main procedure • The first set of statements initializes glfw and creates the window that we will use for our example • The second set of statements initializes glew and reports any errors • glfw provides the interface between OpenGL and the operating system • glew provides the include files for OpenGL, plus any extensions CSCI 3090 OpenGL Programming - Part One 49 Example One GLFWwindow *window; // start by setting error callback in case something goes wrong glfwSetErrorCallback(error_callback); // initialize glfw if (!glfwInit()) { fprintf(stderr, \"can't initialize GLFW\\n\"); } // create the window used by our application window = glfwCreateWindow(512, 512, \"Example One\", NULL, NULL); if (!window) { glfwTerminate(); exit(EXIT_FAILURE); } glfwMakeContextCurrent(window); GLenum error = glewInit(); if(error != GLEW_OK) { printf(\"Error starting GLEW: %s\\n\",glewGetErrorString(error)); exit(0); }"
  },
  "664e0838-e737-4985-ac3e-52c816943905": {
    "text": "the include files for OpenGL, plus any extensions CSCI 3090 OpenGL Programming - Part One 49 Example One GLFWwindow *window; // start by setting error callback in case something goes wrong glfwSetErrorCallback(error_callback); // initialize glfw if (!glfwInit()) { fprintf(stderr, \"can't initialize GLFW\\n\"); } // create the window used by our application window = glfwCreateWindow(512, 512, \"Example One\", NULL, NULL); if (!window) { glfwTerminate(); exit(EXIT_FAILURE); } glfwMakeContextCurrent(window); GLenum error = glewInit(); if(error != GLEW_OK) { printf(\"Error starting GLEW: %s\\n\",glewGetErrorString(error)); exit(0); } CSCI 3090 OpenGL Programming - Part One 50 Example One • The second half of the main procedure is shown on the following slide • first we call our init() procedure • We then set the clear colour to white, to give us a white background • Finally we have a loop that displays the triangle while waiting for input CSCI 3090 OpenGL Programming - Part One 51 Example One init(); glClearColor(1.0,1.0,1.0,1.0); glfwSwapInterval(1); // GLFW main loop, display model, swapbuffer and check for input while (!glfwWindowShouldClose(window)) { display(); glfwSwapBuffers(window); glfwPollEvents(); } glfwTerminate(); CSCI 3090 OpenGL Programming - Part One 52 Example One • What is this swap buffers stuff? • We don’t want to write on the screen while its being displayed • With larger models the rendering process can take several screen refresh times, if we draw directly on the screen it will look ugly • Instead, we use two buffers: • Front buffer – what is displayed on the screen • Back buffer – where OpenGL will draw our model • When drawing is finished the buffers are swapped, this gives us a nice clean image CSCI 3090 OpenGL Programming - Part One 53 Example One • All we have left is our vertex and fragment programs that are stored on separate files • The vertex shader program is shown on the next slide • It starts with a #version, which tells the GLSL compiler which version of OpenGL that we are using, 330 stands for version 3.3 • The first thing we do is declare vPosition, this is an input to our program so the declaration starts with in • The declarations for variables that are outputs start with out CSCI 3090 OpenGL Programming - Part One 54 Example One #version 330 core /* * Simple vertex shader for example one */ in vec4 vPosition; void main() { gl_Position = vPosition; } CSCI 3090 OpenGL Programming -"
  },
  "f69007af-868f-424b-905d-00cd5315e5dc": {
    "text": "OpenGL that we are using, 330 stands for version 3.3 • The first thing we do is declare vPosition, this is an input to our program so the declaration starts with in • The declarations for variables that are outputs start with out CSCI 3090 OpenGL Programming - Part One 54 Example One #version 330 core /* * Simple vertex shader for example one */ in vec4 vPosition; void main() { gl_Position = vPosition; } CSCI 3090 OpenGL Programming - Part One 55 Example One • This is followed by the type, which is a vector of 4 floating point values • How does this work, we are only passing in two floats for each vertex? • In the GPU vertex coordinates are 4 vectors, so our vertex coordinates are padded to 4 values • The main procedure is executed once for each vertex in our program, all it does is copy the vertex coordinates to the next stage CSCI 3090 OpenGL Programming - Part One 56 Example One • Recall: glVertexAttribPointer(vPosition, 2, GL_FLOAT, GL_FALSE, 0, 0); • Here we told OpenGL that each vertex attribute for vPosition consists of 2 floats (x, y). That means for every vertex, only 2 values are coming from your buffer. • When you pass fewer components than the GLSL variable expects, OpenGL fills in the missing values automatically as follows: • If you supply 1 float → GLSL receives (x, 0.0, 0.0, 1.0) • If you supply 2 floats → GLSL receives (x, y, 0.0, 1.0) • If you supply 3 floats → GLSL receives (x, y, z, 1.0) CSCI 3090 OpenGL Programming - Part One 57 Example One • The fragment program is shown on the next slide • This is even simpler, it just sets the fragment colour to red • The main procedure is called once for each fragment, think pixel for now • A colour value has four components: red, green, blue and alpha (the transparency of the pixel) CSCI 3090 OpenGL Programming - Part One 58 Example One #version 330 core /* * Simple fragment shader for example one */ void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } CSCI 3090 OpenGL Programming - Part One 59 Example One • Shader programs should be stored in pure text files, i.e. straight ASCII characters • On Windows use something like notepad to edit them • For program development"
  },
  "d43d6f98-fef5-4252-8349-5dfaa06808b3": {
    "text": "red, green, blue and alpha (the transparency of the pixel) CSCI 3090 OpenGL Programming - Part One 58 Example One #version 330 core /* * Simple fragment shader for example one */ void main() { gl_FragColor = vec4(1.0, 0.0, 0.0, 1.0); } CSCI 3090 OpenGL Programming - Part One 59 Example One • Shader programs should be stored in pure text files, i.e. straight ASCII characters • On Windows use something like notepad to edit them • For program development we usually store the shader programs in external files, this make it easier to debug them during program development • For distribution they can be placed in the C++ code as character string constants CSCI 3090 OpenGL Programming - Part One 60 Example One • This is fairly long, but we have covered most of the process • This gives you a template for building your own applications • The other examples are incremental and build on what we have done so far CSCI 3090 OpenGL Programming - Part One 61 Example One • To build the example code, download Example1.zip from Canvas and unzip it into your Examples folder • Next build the program • Before you run the program copy the fragment and vertex shaders into the debug folder • Also copy the dll’s into this folder CSCI 3090 OpenGL Programming - Part One 62 Example One • One of the problems that students have is they try to run the program from Visual Studio • This will not work, well if you are really good at Visual Studio you know how to do this • Visual Studio will not set up your debug folder correctly and you will get no output • You need to make sure that the shader programs and the dll’s are in the debug folder CSCI 3090 OpenGL Programming - Part One 63 Example One CSCI 3090 OpenGL Programming - Part One 64 Example One • For some of the program you can double click on the .exe in the debug folder, this works for the early examples • For some of the later examples there are program parameters that need to be specified on the command line • In this case you need run the program from the command prompt • The next slide shows this CSCI 3090 OpenGL Programming - Part One 65 Example One CSCI 3090 OpenGL Programming - Part"
  },
  "0f2f84fb-657e-40d8-acc0-77a39b0948a6": {
    "text": "Example One • For some of the program you can double click on the .exe in the debug folder, this works for the early examples • For some of the later examples there are program parameters that need to be specified on the command line • In this case you need run the program from the command prompt • The next slide shows this CSCI 3090 OpenGL Programming - Part One 65 Example One CSCI 3090 OpenGL Programming - Part One 66 Shader Errors • What happens if there is an error in a vertex or fragment shader? • You will not get an error message in Visual Studio, remember Visual Studio isn’t compiling these programs • The error messages will appear in the command prompt window • This is why it’s a good idea to run your program from the command prompt • If a shader doesn’t compile, nothing will be displayed CSCI 3090 OpenGL Programming - Part One 67 Example Two • Example two is a bit more exciting, we have a rotating triangle • This example illustrates the use of transformations and the glm library • It also shows how simple animations can be performed in OpenGL programs • This example starts with the code for example one and adds to it CSCI 3090 OpenGL Programming - Part One 68 Example Two • To make our triangle rotate we need to use a rotation transformation • All transformations in OpenGL are represented by matrices, either 4x4 matrices or 3x3 matrices • To combine transformations, we multiply their matrices • To transform a point, we multiply the point by the transformation matrix • Don’t worry too much about transformations now, we will discuss them in detail in the next part of the course CSCI 3090 OpenGL Programming - Part One 69 Example Two • For this example, we will rotate the triangle about the z axis, the axis coming out of the screen • Since we want to animate the rotation we will have a variable, angle, that changes each time we draw the triangle • Now we need to know how to construct the matrix that will perform the rotation CSCI 3090 OpenGL Programming - Part One 70 Example Two • glm has a function called rotate that will construct the transformation matrix • The first parameter to this function is the previous transformation matrix, in our"
  },
  "e6bd49c9-572c-4980-9ce0-c1e4d16cae67": {
    "text": "coming out of the screen • Since we want to animate the rotation we will have a variable, angle, that changes each time we draw the triangle • Now we need to know how to construct the matrix that will perform the rotation CSCI 3090 OpenGL Programming - Part One 70 Example Two • glm has a function called rotate that will construct the transformation matrix • The first parameter to this function is the previous transformation matrix, in our case the identity matrix • The second parameter is the rotation angle, in radians • The third parameter is the rotation axis, the axis we are rotating about CSCI 3090 OpenGL Programming - Part One 71 Example Two • The next slide shows our new display() procedure • It starts with two declarations, the first one is for the transformation matrix • Our vertex shader program will use this matrix, the location of this matrix in the shader program is modelLoc • Note that we use the glm:: scope for all of the glm data types and procedures CSCI 3090 OpenGL Programming - Part One 72 Example Two void display () { glm::mat4 model; int modelLoc; model = glm::rotate(glm::mat4(1.0), angle, glm::vec3(0.0, 0.0, 1.0)); glClear(GL_COLOR_BUFFER_BIT); glUseProgram(program); modelLoc = glGetUniformLocation(program,\"model\"); glUniformMatrix4fv(modelLoc, 1, 0, glm::value_ptr(model)); glBindVertexArray(triangleVAO); glDrawElements(GL_TRIANGLES, 3, GL_UNSIGNED_SHORT, NULL); } Note that model is a C++ class, we can’t directly pass model as a parameter . Instead, we need to get a pointer to its data. CSCI 3090 OpenGL Programming - Part One 73 Example Two • Next we have the statement that constructs the matrix • The function glm::mat4(1.0) creates a 4x4 identity matrix • The next new thing is the call to glGetUniformLocation, to find the shader variable where we will store the matrix • This is a variable that is stored on the GPU, it is part of the vertex shader program • This is part of the communications between the CPU and the GPU CSCI 3090 OpenGL Programming - Part One 74 Example Two • There are two common types of shader variables • We have already seen attribute variables, they get a new value for each vertex or fragment • Our transformation matrix will be a uniform variable, a variable that has the same value for many vertices or fragments • We find the location of these variables in essentially the same way as attribute variable, except"
  },
  "000d9355-da86-4f4f-ad10-c1157ced6782": {
    "text": "between the CPU and the GPU CSCI 3090 OpenGL Programming - Part One 74 Example Two • There are two common types of shader variables • We have already seen attribute variables, they get a new value for each vertex or fragment • Our transformation matrix will be a uniform variable, a variable that has the same value for many vertices or fragments • We find the location of these variables in essentially the same way as attribute variable, except we use a different procedure CSCI 3090 OpenGL Programming - Part One 75 Example Two • The glUniformMatrix4fv procedure is used to transfer the matrix to the GPU • The “4fv” in the name specifies a 4x4 matrix of float values passed by a pointer • The first parameter is the shader variable to receive the matrix • The second parameter is the number of matrices, we could have an array of matrices in the shader program CSCI 3090 OpenGL Programming - Part One 76 Example Two • The third parameter is a flag to indicate whether the matrix should be transposed, we don’t want this • The final parameter is a pointer to the matrix • model is a C++ object that contains the transformation matrix • Can’t directly pass a C++ object, since it has more than the data • It also contains information on the object and possibly pointers to virtual functions • We use the glm::value_ptr() function to retrieve the actual matrix from model CSCI 3090 OpenGL Programming - Part One 77 Example Two • Now lets examine the vertex shader program, shown on the next slide • Note that we have a uniform variable called model which matches the transformation matrix in our OpenGL program CSCI 3090 OpenGL Programming - Part One 78 Example Two #version 330 core /* * Simple vertex shader for example two */ in vec4 vPosition; uniform mat4 model; void main() { gl_Position = model * vPosition; } CSCI 3090 OpenGL Programming - Part One 79 Example Two • The vertex program multiplies the current vertex by this matrix and passes it down the pipeline • Note that matrix multiplication is a primitive operation in GLSL • How is the angle variable updated so we have a different value each time we draw the triangle? • How do we end up drawing the triangle more than once? CSCI 3090 OpenGL Programming"
  },
  "87dd32f1-1263-430f-9e06-ec2647e50dc3": {
    "text": "{ gl_Position = model * vPosition; } CSCI 3090 OpenGL Programming - Part One 79 Example Two • The vertex program multiplies the current vertex by this matrix and passes it down the pipeline • Note that matrix multiplication is a primitive operation in GLSL • How is the angle variable updated so we have a different value each time we draw the triangle? • How do we end up drawing the triangle more than once? CSCI 3090 OpenGL Programming - Part One 80 Example Two • We can update the angle in the loop we have at the end of the main() procedure • We have a global variable angle that is initialized to zero • This variable is referenced in the display() procedure • The following slide shows how it is updated in the display loop CSCI 3090 OpenGL Programming - Part One 81 Example Two while (!glfwWindowShouldClose(window)) { display(); glfwSwapBuffers(window); glfwPollEvents(); angle = angle + 0.1; } CSCI 3090 OpenGL Programming - Part One 82 Example Two • We add 0.1 radians to angle each time we go through the loop • Increasing this value makes the triangle spin faster • Deceasing this value makes the triangle spin slower • The glm library has a number of useful functions • It has functions to construct scale and translation matrices • It also has functions for viewing transformation, which we will use in the fourth example CSCI 3090 OpenGL Programming - Part One 83 Example Three • Our triangle still looks kind of boring, we can improve this by adding some simulated lighting • We haven’t discussed light models yet, it’s part of rendering, so we will just use a very simple one • To do lighting we need to have a normal vector at each vertex, in our case the normal is just (0,0,1) CSCI 3090 OpenGL Programming - Part One 84 Example Three • To add normal vectors we need to make some changes to our init() procedure • First we construct an array of normal vectors, one for each vertex, the code for doing this is: GLfloat normals[3][3] = { {0.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {0.0, 0.0, 1.0} }; CSCI 3090 OpenGL Programming - Part One 85 Example Three • Next, we need to add the normals to the same buffer that contains the vertices • The code for doing this is shown on"
  },
  "6b4fa9d9-fee0-4747-90c8-f3d4fa8df429": {
    "text": "normal vectors we need to make some changes to our init() procedure • First we construct an array of normal vectors, one for each vertex, the code for doing this is: GLfloat normals[3][3] = { {0.0, 0.0, 1.0}, {0.0, 0.0, 1.0}, {0.0, 0.0, 1.0} }; CSCI 3090 OpenGL Programming - Part One 85 Example Three • Next, we need to add the normals to the same buffer that contains the vertices • The code for doing this is shown on the next slide • The call to glBufferData now allocates enough memory for both the vertex coordinates and the normal vectors • We add a second call to glBufferSubData to copy the normal vectors into the buffer • The normal vectors will appear after the vertex coordinates in the buffer CSCI 3090 OpenGL Programming - Part One 86 Example Three glGenBuffers(1, &vbuffer); glBindBuffer(GL_ARRAY_BUFFER, vbuffer); glBufferData(GL_ARRAY_BUFFER, sizeof(vertices)+sizeof(normals), NULL, GL_STATIC_DRAW); glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertices), vertices); glBufferSubData(GL_ARRAY_BUFFER, sizeof(vertices), sizeof(normals), normals); CSCI 3090 OpenGL Programming - Part One 87 Example Three • In the vertex shader the vNormal variable will receive the normal vectors, so we need to specify this in the OpenGL program: vNormal = glGetAttribLocation(program, \"vNormal\"); glVertexAttribPointer(vNormal, 3, GL_FLOAT, GL_FALSE, 0, (void*) sizeof(vertices)); glEnableVertexAttribArray(vNormal); • The last parameter to glVertexAttribPointeris the location in the buffer where the normal vectors are stored CSCI 3090 OpenGL Programming - Part One 88 Example Three • The only other change to the OpenGL programs is to rotate about the y axis instead of the z axis • The vertex program for this example is shown on the next slide • There are several new things here • First, we have an out variable, this is the transformed normal vector that will be passed to the fragment program CSCI 3090 OpenGL Programming - Part One 89 Example Three #version 330 core /* * Simple vertex shader for example three */ in vec4 vPosition; in vec3 vNormal; uniform mat4 model; out vec3 normal; void main() { gl_Position = model * vPosition; normal = (model * vec4(vNormal,1.0)).xyz; } CSCI 3090 OpenGL Programming - Part One 90 Example Three • Next, we have the line that transforms the normal vector • Our transformation matrix is 4x4, but the normal vector has only three components • We need to add the fourth component, multiply by the matrix and then extract just the first three components CSCI 3090 OpenGL Programming - Part One"
  },
  "423af772-feed-4da7-85ce-6556683dece5": {
    "text": "model; out vec3 normal; void main() { gl_Position = model * vPosition; normal = (model * vec4(vNormal,1.0)).xyz; } CSCI 3090 OpenGL Programming - Part One 90 Example Three • Next, we have the line that transforms the normal vector • Our transformation matrix is 4x4, but the normal vector has only three components • We need to add the fourth component, multiply by the matrix and then extract just the first three components CSCI 3090 OpenGL Programming - Part One 91 Example Three • In general, the way we are transforming the normal vector is incorrect • We should use the inverse transpose of the transformation matrix • But since our matrix is a rotation matrix, its inverse transpose is the original matrix • We will see the correct way of doing this in the next example CSCI 3090 OpenGL Programming - Part One 92 Example Three • Now we turn to the fragment program, shown on the next slide • This program has an input variable, the normal vector computed by the vertex program • We normalize this to get the variable N, L is the direction to the light source • We take the dot product of these two vectors to get the diffuse light component CSCI 3090 OpenGL Programming - Part One 93 Example Three #version 330 core in vec3 normal; void main() { vec3 N; vec3 L = vec3(0.0, 0.0, 1.0); vec4 colour = vec4(1.0, 0.0, 0.0, 1.0); float diffuse; N = normalize(normal); diffuse = dot(N,L); if(diffuse < 0.0) { diffuse = 0.0; } gl_FragColor = min(0.3*colour + 0.7*diffuse*colour, vec4(1.0)); gl_FragColor .a= colour .a; } CSCI 3090 OpenGL Programming - Part One 94 Example Three • If the light source is behind the triangle the dot produce will be negative, in this case we set the diffuse light to zero • The variable colour contains the colour of the triangle • The final colour is 30% ambient (a constant term) and 70% diffuse • Watch the triangle as it rotates and see how the colour changes CSCI 3090 OpenGL Programming - Part One 95 Example Four • Our final example introduces 3D viewing • So far, we’ve used a fixed viewpoint where we were looking down the z axis, this was essentially a 2D view • Now we will introduce a perspective projection and the ability to move the eye position CSCI 3090 OpenGL Programming -"
  },
  "bc54528a-9d46-41a1-bf7f-a358c40fd0a3": {
    "text": "ambient (a constant term) and 70% diffuse • Watch the triangle as it rotates and see how the colour changes CSCI 3090 OpenGL Programming - Part One 95 Example Four • Our final example introduces 3D viewing • So far, we’ve used a fixed viewpoint where we were looking down the z axis, this was essentially a 2D view • Now we will introduce a perspective projection and the ability to move the eye position CSCI 3090 OpenGL Programming - Part One 96 Example Four • Recall the viewing frustum from the previous lecture, see the next slide • There are two parts to viewing: one is the shape of the frustum, and the other is the position of the frustum • The perspective projection determines the shape of the viewing frustum, and this is usually constant CSCI 3090 OpenGL Programming - Part One 97 Example Four CSCI 3090 OpenGL Programming - Part One 98 Example Four • The position of the frustum can change each time we draw the window • This is called the viewing transformation • So, it makes sense to construct two matrices, one for the perspective transformation and the other for the viewing transformation • Our program will follow this approach CSCI 3090 OpenGL Programming - Part One 99 Example Four • For the perspective transformation the framebufferSizeCallback() function is called each time the size of the window changes • This will occur at least once at the start of our program • This function constructs the perspective matrix based on the aspect ratio of the window, the ratio of width to height • This function is registered in the main function using the following statement: glfwSetFramebufferSizeCallback(window, framebufferSizeCallback); CSCI 3090 OpenGL Programming - Part One 100 Example Four void framebufferSizeCallback(GLFWwindow *window, int w, int h) { // Prevent a divide by zero, when window is too short // (you cant make a window of zero width). if (h == 0) h = 1; float ratio = 1.0f * w / h; glfwMakeContextCurrent(window); glViewport(0, 0, w, h); projection = glm::perspective(0.7f, ratio, 1.0f, 100.0f); } CSCI 3090 OpenGL Programming - Part One 101 Example Four • The glm::perspective function is used to construct the perspective matrix • The first parameter is the field of view of the frustum • The second parameter is the aspect ratio of the window • The third and fourth parameters are the"
  },
  "45c42672-dddc-4611-a13c-ef4a4d1a484a": {
    "text": "width). if (h == 0) h = 1; float ratio = 1.0f * w / h; glfwMakeContextCurrent(window); glViewport(0, 0, w, h); projection = glm::perspective(0.7f, ratio, 1.0f, 100.0f); } CSCI 3090 OpenGL Programming - Part One 101 Example Four • The glm::perspective function is used to construct the perspective matrix • The first parameter is the field of view of the frustum • The second parameter is the aspect ratio of the window • The third and fourth parameters are the near and far clipping planes • This is a pretty standard set up that we will use in most of our programs • More on perspective transformations later in rendering CSCI 3090 OpenGL Programming - Part One 102 Example Four • The viewing transformation matrix is constructed in the display() function • The first part of this function is shown on the next slide • The glm::lookat function constructs the viewing matrix • The first parameter to this function is the eye position, this is computed in a separate function CSCI 3090 OpenGL Programming - Part One 103 Example Four void display () { glm::mat4 model; glm::mat4 view; glm::mat4 modelViewPerspective; int modelLoc; int normalLoc; model = glm::rotate(glm::mat4(1.0), angle, glm::vec3(0.0, 1.0, 0.0)); view = glm::lookAt(glm::vec3(eyex, eyey, eyez), glm::vec3(0.0f, 0.0f, 0.0f), glm::vec3(0.0f, 1.0f, 0.0f)); glm::mat3 normal = glm::transpose(glm::inverse(glm::mat3(view*model))); modelViewPerspective = projection * view * model; CSCI 3090 OpenGL Programming - Part One 104 Example Four • The second parameter is the position the eye is looking at • The third parameter is the up vector, this is the direction that is up in the view • Note: the eye positon and look at position define a line, the direction the viewer is looking • The frustum can rotate about this line, the up vector fixes this rotation CSCI 3090 OpenGL Programming - Part One 105 Example Four • The vertices will be transformed by the combination of the perspective, viewing and model transformations • This is the modelViewPerspective matrix • The normal vectors are only transformed by the view and model transformation • The matrices are combined, the inverse and transpose are taken, this is assigned to the normal variable CSCI 3090 OpenGL Programming - Part One 106 Example Four • The following statement are then used to send the matrices to the GPU: modelLoc = glGetUniformLocation(program,\"model\"); glUniformMatrix4fv(modelLoc, 1, 0, glm::value_ptr(modelViewPerspective)); normalLoc = glGetUniformLocation(program,\"normalMat\"); glUniformMatrix3fv(normalLoc, 1, 0, glm::value_ptr(normal)); CSCI 3090 OpenGL Programming"
  },
  "b0cf516f-8c7f-46e7-980b-bf8d17babc52": {
    "text": "transformations • This is the modelViewPerspective matrix • The normal vectors are only transformed by the view and model transformation • The matrices are combined, the inverse and transpose are taken, this is assigned to the normal variable CSCI 3090 OpenGL Programming - Part One 106 Example Four • The following statement are then used to send the matrices to the GPU: modelLoc = glGetUniformLocation(program,\"model\"); glUniformMatrix4fv(modelLoc, 1, 0, glm::value_ptr(modelViewPerspective)); normalLoc = glGetUniformLocation(program,\"normalMat\"); glUniformMatrix3fv(normalLoc, 1, 0, glm::value_ptr(normal)); CSCI 3090 OpenGL Programming - Part One 107 Example Four • This example uses keystrokes to control the eye position • The key_callback() procedure shown on the next slide does this • This function is called each time a key is pressed on the keyboard • A sequence of if statements is used to determine the key that was pressed and perform the appropriate action CSCI 3090 OpenGL Programming - Part One 108 Example Four static void key_callback(GLFWwindow* window, int key, int scancode, int action, int mods) { if (key == GLFW_KEY_ESCAPE && action == GLFW_PRESS) glfwSetWindowShouldClose(window, GLFW_TRUE); if (key == GLFW_KEY_A && action == GLFW_PRESS) phi -= 0.1; if (key == GLFW_KEY_D && action == GLFW_PRESS) phi += 0.1; if (key == GLFW_KEY_W && action == GLFW_PRESS) theta += 0.1; if (key == GLFW_KEY_S && action == GLFW_PRESS) theta -= 0.1; eyex = (float)(r*sin(theta)*cos(phi)); eyey = (float)(r*sin(theta)*sin(phi)); eyez = (float)(r*cos(theta)); } CSCI 3090 OpenGL Programming - Part One 109 Example Four • What is this doing? • We are placing the viewer, the eye position, on a sphere that encloses the object • The variable r is the radius of this sphere • The variables theta and phi give the angular position of the eye • This allows us to view the object from different directions • This isn’t the best technique, but it’s simple CSCI 3090 OpenGL Programming - Part One 110 Example Four • The variables eyex, eyey and eyez are initialized in the main function • The vertex shader is shown on the next slide • This is similar to the previous example, except in this case we have a separate matrix for the normal vectors • There is no change in the fragment shader CSCI 3090 OpenGL Programming - Part One 111 Example Four in vec4 vPosition; in vec3 vNormal; uniform mat4 model; uniform mat3 normalMat; out vec3 normal; void main() { gl_Position = model * vPosition; normal ="
  },
  "62b59113-b561-4d57-bb34-4d128bc2c578": {
    "text": "initialized in the main function • The vertex shader is shown on the next slide • This is similar to the previous example, except in this case we have a separate matrix for the normal vectors • There is no change in the fragment shader CSCI 3090 OpenGL Programming - Part One 111 Example Four in vec4 vPosition; in vec3 vNormal; uniform mat4 model; uniform mat3 normalMat; out vec3 normal; void main() { gl_Position = model * vPosition; normal = normalMat* vNormal; } CSCI 3090 OpenGL Programming - Part One 112 Recap • Really dealing with two programs, one on CPU and one on GPU CPU Program Interface (driver) GPU Program CSCI 3090 OpenGL Programming - Part One 113 Recap Vertex Data Transformations Etc. Vertex And Fragment Shaders Attribute Variables Uniform Variables CPU Side GPU Side CSCI 3090 OpenGL Programming - Part One 114 Program Structure • Example four has over 250 lines of code • Do we have to write this much code from scratch each time • NO! • For most of our programs the changes will be in init() and display(), with possibly a few lines in main() • The rest of the program is cut and paste • For each lab and assignment, start with the example that is closest and just modify that code CSCI 3090 OpenGL Programming - Part One 115 Summary • Examined the basics of OpenGL application development • You can now produce simple OpenGL applications with limited visual effects • More example programs will be examined as we cover more graphics theory CSCI 3090 OpenGL Programming - Part One 116"
  }
}